package com.ruokatracker.ruokatracker_api.controllers.user;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import com.ruokatracker.ruokatracker_api.models.AuthenticateDTO;
import com.ruokatracker.ruokatracker_api.models.login.LoginResponse;
import com.ruokatracker.ruokatracker_api.models.user.User;
import com.ruokatracker.ruokatracker_api.models.user.UserDTO;
import com.ruokatracker.ruokatracker_api.models.user.UserLoginDTO;
import com.ruokatracker.ruokatracker_api.models.user.UserRegisterDTO;
import com.ruokatracker.ruokatracker_api.repositories.UserRepository;
import com.ruokatracker.ruokatracker_api.util.JwtTokenUtil;

import at.favre.lib.crypto.bcrypt.BCrypt;
import jakarta.validation.Valid;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/user") // This means URL's start with /demo (after Application path)
public class UserAuthController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    // simple get to test
    @RequestMapping(path = "/test")
    public @ResponseBody String test() {
        return "Hello World";
    }

    @PostMapping(path = "signup")
    public @ResponseBody ResponseEntity<String> register(@Valid @RequestBody UserRegisterDTO userDTO) {

        if (userRepository.existsByEmail(userDTO.getEmail())) {
            return new ResponseEntity<>("User with this email already exists", HttpStatus.BAD_REQUEST);
        }

        // Hash the password before saving
        User user = new User();
        user.setEmail(userDTO.getEmail());
        user.setPassword(hashPassword(userDTO.getPassword()));
        userRepository.save(user);

        String token = JwtTokenUtil.generateToken(user.getEmail());
        return new ResponseEntity<>(token, HttpStatus.OK);
    }

    @PostMapping(path = "/login")
    public @ResponseBody ResponseEntity<LoginResponse> login(@Valid @RequestBody UserLoginDTO userDTO) {

        User user = userRepository.findByEmail(userDTO.getEmail());

        if (user == null) {
            return new ResponseEntity<>(new LoginResponse(null, null), HttpStatus.UNAUTHORIZED);
        }

        if (!BCrypt.verifyer().verify(userDTO.getPassword().toCharArray(), user.getPassword()).verified) {
            return new ResponseEntity<>(new LoginResponse(null, null), HttpStatus.UNAUTHORIZED);
        }

        String token = JwtTokenUtil.generateToken(user.getEmail());

        // Return both token and user in the response
        LoginResponse loginResponse = new LoginResponse(token, new UserDTO(user));
        return new ResponseEntity<>(loginResponse, HttpStatus.OK);
    }

    @PostMapping(path = "/authenticate")
    public @ResponseBody ResponseEntity<LoginResponse> authenticate(@RequestBody AuthenticateDTO authenticateDTO) {
        String token = authenticateDTO.getToken();
        if (token == null) {
            return new ResponseEntity<>(new LoginResponse(null, null), HttpStatus.UNAUTHORIZED);
        }
        String email = JwtTokenUtil.getEmailFromToken(token);
        User user = userRepository.findByEmail(email);

        if (user == null) {
            return new ResponseEntity<>(new LoginResponse(null, null), HttpStatus.UNAUTHORIZED);
        }

        // return user
        LoginResponse loginResponse = new LoginResponse(token, new UserDTO(user));
        return new ResponseEntity<>(loginResponse, HttpStatus.OK);

    }

    private String hashPassword(String plainPassword) {
        return BCrypt.withDefaults().hashToString(12, plainPassword.toCharArray());
    }
}
